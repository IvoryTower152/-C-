#include <iostream>
#include <vector>
#include <stdio.h>

using namespace std;

int main(){
    double n, m;
    cin >> n >> m;
    if (n > m){
        printf("%.4f", double(0));
        return 0;
    }
    vector< vector<double> > ans(m+1, vector<double>(n+1, 0));
    ans[1][1] = 1.0;
    for (int i = 2; i <= m; i++){
        ans[i][1] = ans[i-1][1] / n;
    }
    for (int i = 2; i <= m; i++){
        for (int j = 2; j <= n; j++){
            ans[i][j] = ans[i-1][j] * j / n + ans[i-1][j-1] * (n-(j-1)) / n;
        }
    }
    printf("%.4f", ans[m][n]);
    return 0;
}

/*
印章

问题描述：
共有n种图案的印章，每种图案的出现概率相同，小明买了m张印章，求小明集齐n种印章的概率

输入格式：
一行两个正整数n和m，分别表示印章的种类和购买的印章数量

输出格式：
一个实数P表示答案，保留4位小数

Note：1<=n, m<=20

输入样例： 2 3
样例输出： 0.7500

解析：
首先，对于n种印章，随机买一个印章的概率就是1/n
第二，这个本质是一个无序的排列组合问题，以(2 3)为例，2种印章进行3个数量的排列组合有
(111, 112, 121, 122, 211, 212, 221, 222)共计8种，其中能够集齐所有的组合有6种，因此概率为0.75

如果是常规解法，首先想到的就是用回溯搜索法，但是发现(20 20)这样的就会使搜索规模变得很大，最终运行超时
更优质的解法其实是动态规划法：
制作DP数组dp[i][j]，表示买i个印章集齐j种印章的概率，此处的概率沿用上述的1/n
最终的目的是得到dp[m][n]，即购买m个印章集齐n种印章的概率

1、对n>m时，毫无疑问集齐的概率为0
2、对于i=1，j=1时，买1个印章一定能收集到1种，dp[1][1]即为1
3、对于i=1，j>1时，1个印章不可能收集到j种，dp[1][j]为0
4、对于i>1，j=1时，表明为购买i个印章为同1种的概率
  它其实可以由dp[1][1]得到，第2张和前面相同的概率是1/n，即dp[1][1]*(1/n)
  以此类推，以(2 3)为例，可以得到初始化的DP数组：
            1   2
        1  1.0  0
        2  0.5
        3  0.25
5、DP最重要的是状态转换，该题的状态转换比较独特，dp[i][j]可以由两种状态得到：
  a.dp[i-1][j-1]，也就是小明买了i-1个印章，其中集齐了j-1种
    dp[i][j]就是小明又买了1个印章，其恰好不是前面j-1种印章的概率，即dp[i-1][j-1]*(n-(j-1))/n
  b.dp[i-1][j]，也就是小明买了i-1个印章，其中集齐了j种
    那么只要小明不买到新的印章，他就能顺利来到dp[i][j]，即新买的印章是已有的j种中的一个
    那么这概率为dp[i-1][j]*(j/n)
6、以上两个均为dp[i][j]的状态转换，两个相加即为所求值
            1   2
        1  1.0  0
        2  0.5  0.5
        3  0.25 0.75
  最终dp[3][2]得到0.75

再以(3, 3)为例，通过排列组合我们可以得到3种类印章，买3个集齐的组合有6种，概率为6/27=2/9
如果以DP方式进行，首先1种印章的概率为1/3，dp初始化为
    1       2       3
1   1       0       0
2   1/3
3   1/9

状态转移 dp[2][2] += dp[1][1]*(n-2+1)/n = 2/3 
dp[2][2] += dp[1][2]*2/n = 0

    1       2       3
1   1       0       0
2   1/3     2/3     0
3   1/9

    1       2       3
1   1       0       0
2   1/3     2/3     0
3   1/9     6/9     2/9

还能发现一个规律，这个dp的每行相加正好1.0
*/